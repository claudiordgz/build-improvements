
section
    h1 Build Improvements
    h2 Workflow for Newstalk and Methode
    h3 Questions
    h4 claudio.rdgz@gmail.com

section
    section
        h2 Module Loading
        h3 Module
        p Any of a number of distinct but interrelated units from which a program may be built up or into which a complex activity may be analyzed.
    section
        h2 The current state of Newstalk
        .container
            .row
                .col-xs-4
                    img(id="newstalk-dependencies")
                .col-xs-8
                    .left-align.
                        We have several javascript files for a relatively small project in Newstalk,
                        the problem with this approach is that We must document the scope of things.
                    ul.left-list__padding
                        li Does the file belong to the page?
                        li Higher level?
                        li Is it a module or some utility functions to use all around?
    section
        h2 Dependency Management
        .container
            .row
                .col-md-12
                    img(id="newstalk-footer", style='max-width:750px;')
            .row
                .col-md-12
                    p We don't know which Javascript file is using what without reading the whole code.
    section
        h2 Requests
        p Modules should be small because it is easier to pick up, extend, and find bugs in a small module.
        p But loading many modules through HTTP-Requests is slow.
        p Bundling modules reduces the amount of necessary HTTP-Requests to load our app.

section
    section
        h2 What are the famous types of modules in Javascript
        h3 RequireJS vs Browserify
        p.
            NOTE: There modules are concepts the Web agreed upon based on famous
            design patterns like AMD pattern and Revealing Module Pattern, they
            are not Frameworks.

    section
        h2 RequireJS
        p Asynchronous Module Definition (AMD) style modules
        pre
            code.hjs.javascript.
                define([
                  'jquery',
                  'underscore',
                  'backbone',
                  'router',
                ], function($, _, Backbone, Router){
                  var initialize = function(){
                    Router.initialize();
                  }

                  return {
                    initialize: initialize
                  };
                });

    section
        h2 RequireJS
        .container
            .row
                .col-md-6
                    p The Good
                    ul
                        li It's been around
                        li Designed for async loading
                .col-md-6
                    p The Bad
                    ul
                        li It is not simple to define
                        li Massive configuration for changes
                        li Does not scale
    section
        h2 Browserify
        p Based on CommonJS style modules, which came before AMD, but were not supported by all browsers at the time.
        h3
            p.custom-font.color--red.
                It is used on Last Songs Player Front End
        pre
            code.hjs.javascript.
                var $ = require('jquery');
                var _ = require('lodash');
                var backbone = require('backbone');
                var router = require('Router');

                  var initialize = function(){
                    Router.initialize();
                  }

                module.exports = initialize;
    section
        h2 Browserify
        .container
            .row
                .col-md-6
                    h2 The Good
                    ul
                        li Use npm / node.js libraries
                        li.
                            Plays well with Gulp/Grunt. => powerful processing strategies.
                        li CommonJS syntax is better
                .col-md-6
                    h2 The Bad
                    ul
                        li you need Gulp/Grunt and plugins for instant dev rebuilds.
                        li.
                            Default: bundling into a single file. Async loading & multiple bundles
                            possible, but must be done manually.
    section
        h2 Conclusion
        p When loading AMD modules it is important to keep track of the availability of the modules
        p.
            Both solutions get the job done well, but there are rough edges here
            and there.
        p Having CommonJS modules does not solve the need for async modules.
section
    h2 Requirements for a good bundler
    .container
        .row
            .col-md-6
                h2 Production
                ul
                    li bundling strategy that makes your app load quickly:
                    li Deliver modules that are needed at the same time in one HTTP-Request.
                    li Deliver independent modules separately.
                    li Optimize size of bundles and their caching.
            .col-md-6
                h2 Development
                ul
                    li Deliver changes to modules instantly.
                    li Importing dependencies into your modules should be easy.
                    li Minimal configuration / processing scripts.
section
    h2 Webpack
    h3 DISCLAIMER:  Newspaper is using it on the 512 project
    h3 and this presentation too!

    p Instagram/Facebook hypes it, Yahoo uses it as well.


section

    h2 Definition style agnostic

    p Supports AMD, CommonJS and even ES6 modules


section

    h2 Everything is a module

    p Why do other bundlers only care about Javascript modules?

    p There are other assets that need bundling! Webpack enables you to do that.


section(data-state="white-background")

    p Take the full dependency graph of all assets, and bundle them to your liking

    img#what-is-webpack


section

    h2 Bundling into one file is not enough

    p If our app is big, you would like to split the assets into multiple files:

    p Webpack will offer you powerful bundling strategies with minimal configuration



section

    h2 Dev experience is great

    p.
        Webpack ships awesome dev-tools that provide instant rebuilds with
        hot reload.


section

    h2 How to use Webpack
    pre
        code.hjs.javascript.
            // ------------------
            // webpack.config.js
            // ------------------

            module.exports = {
                entry: ['./src/app.js'],
                output: {
                    path: __dirname + '/build/js',
                    filename: 'bundle.js',
                    publicPath: '/js/'
                }
            };

    pre
        code.bash.
            bash:~$ webpack

section

    h2 How the hell do I bundle pngs and css?


    pre
        code.hljs.javascript.

            //yes, we require sass!
            require('./mySassForThisModule.scss');

            var _ = require('lodash');
            var FooComponent = require('./FooComponent.jsx');

            //yes, we require png!
            var imageLink = require('../../img/myImage.png');

            // do something with imageLink, FooComponent and lodash

            module.exports = ThisModule;

    p.
        If you bundle this with webpack, all the assets will be automagically
        available when you include your bundle into your html document.


section

    h2 Loaders

    blockquote(cite="http://webpack.github.io/docs/loaders.html").
        Loaders are transformations that are applied on files. They preprocess files.
        For instance they can transform CoffeeScript to JavaScript.


section

    h2 Lots of Loaders (via npm)
    ul
        li inlining stylesheets
        li various preprocessors (jsx, CoffeeScript, es6)
        li templates
        li files, jsons, source-maps
        li promises, webworkers


section

    h2 Loader Configuration

    pre
        code.hljs.javascript.
            // ------------------
            // webpack.config.js
            // ------------------
            ...,
            module: {
                loaders: [
                    {
                        test: /\.js.{0,1}$/,
                        loader: 'jsx?harmony'
                    },{
                        test: /\.scss$/,
                        loader: "style!css!sass?outputStyle=expanded&includePaths[]=" + __dirname + '/src/scss'
                    }, {
                        test: /\.css$/,
                        loader: "style!css"
                    }
                ],
            },
            ...


section

    h2 Loaders are awesome

    p requiring and inlining stylesheets is super helpful.

    p you get all the freedom you need with preprocessors.

    p you can do cool stuff like inlining small pngs or json files.

    p bye bye Grunt/Gulp.


section

    h2 So your project is big...


section

    h2 Load on Demand

    p Create splitpoints

    pre
        code.hljs.javascript.

            require.ensure(["./otherPart.js"], function (otherPart) {
                // now you can use otherPart
            });

    p.
        This will create two files (called chunks by Webpack).
        One is your entrypoint, the other gets loaded on demand.


section

    h2 Multiple Entrypoints

    p Run the CommonsChunkPlugin to split code up

    pre
        code.hljs.javascript.
            {
                entry: { a: "./a", b: "./b" },
                output: { filename: "[name].js" },
                plugins: [ new webpack.CommonsChunkPlugin("common.js") ]
            }


section

    h2 Caching

    p Add hashes to your filenames

    pre
        code.hljs.javascript.
            output: {
                path: path.join(__dirname, "assets", "[hash]"),
                publicPath: "assets/[hash]/",
                filename: "output.[hash].bundle.js",
                chunkFilename: "[id].[hash].bundle.js"
            }


section

    h2 There is more

    ul
        li uglify
        li dedupe
        li various chunk optimizations (max chunk count, min chunk size)
        li gulp/grunt
        li target various runtimes


section

    h2 Development productivity


section

    h2 webpack-dev-server

    p Incremental (=instant) rebuilds

    p hot reload without plugins


section

    h2 dev-server setup

    pre
        code.hljs.javascript.
            // ------------------
            // server.js
            // ------------------
            "use strict";
            var webpack = require('webpack');
            var WebpackDevServer = require('webpack-dev-server');
            var config = require('./webpack.config');

            var server = new WebpackDevServer(webpack(config), {
                // webpack-dev-server options
                hot: true,
                contentBase: __dirname,
                quiet: false,
                noInfo: false,
                publicPath: '/js/',
                stats: { colors: true }
            });

            server.listen(8081, "localhost", function() {});

section

    h2 dev-server setup (2)

    pre
        code.hljs.javascript.
            // ------------------
            // webpack.config.js
            // ------------------
            entry: [
                './slides-loader.js',
                'webpack/hot/dev-server',
                'webpack-dev-server/client?http://localhost:8081'
            ],
            plugins: [new webpack.HotModuleReplacementPlugin()],

section

    h2 Live Demo!

section

    h2 Further Reading

    li
        a(href="http://webpack.github.io/docs/") http://webpack.github.io/docs/

        span  (especially list of tutorials)

    li
        a(href="https://github.com/petehunt/webpack-howto").
            https://github.com/petehunt/webpack-howto
section

    h2 Wrap-Up

    li Good bundling is important (and easier than server-side rendering)

    li Webpack combines the strengths of RequireJS and Browserify

    li Webpack is a bundler for everbody

    li It is easy to migrate

    li Webpack is well supported (because of the cool kids)